<script>
  window.onload = (event) => {
    //load every data to a array
    google.script.run.withSuccessHandler(startUpLoadData).getCableNames()
  }

  var cleanReport;
  var globalSelectedDates = [];
  var globalSelectedYear = new Date().getFullYear();
  var globalSelectedMonth = new Date().getMonth();
  //TODO Make a Collection --- sa papel ani ang flow--- OBJECT - ARRAY - OBJECT - ARRAY
  var collections = [{
    cableName: 'SEAUS',
    incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
    [{ dry: [], wet: [], under: [], back: [] }]]
  },
  {
    cableName: 'SJC',
    incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
    [{ dry: [], wet: [], under: [], back: [] }]]
  },
  {
    cableName: 'C2C',
    incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
    [{ dry: [], wet: [], under: [], back: [] }]]
  },
  {
    cableName: 'EAC',
    incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
    [{ dry: [], wet: [], under: [], back: [] }]]
  },
  {
    cableName: 'TGN',
    incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
    [{ dry: [], wet: [], under: [], back: [] }]]
  }]; // Collections that will show in the graph
  //Initialized para dili labad mag debug


  function getReport(cables) {
    var box_of_cables = []
    if (globalSelectedDates.length > 1) {
      for (let i = 0; i < cables.length; i++) {
        if (new Date(cables[i].startDate).setHours(0, 0, 0, 0) >= new Date(globalSelectedDates[0]).setHours(0, 0, 0, 0) && new Date(cables[i].startDate).setHours(0, 0, 0, 0) <= new Date(globalSelectedDates[globalSelectedDates.length - 1]).setHours(0, 0, 0, 0)) {
          box_of_cables.push(cables[i]);
        }
      }
      incidentTypeChecker(box_of_cables)
      console.log(collections);
    }
    else {
      cables.forEach(element => {
        if (new Date(element.startDate).getMonth() == globalSelectedMonth && new Date(element.startDate).getFullYear() == globalSelectedYear) { // added one cuz 1st month starts at 0
          box_of_cables.push(element)
        }
      });
      incidentTypeChecker(box_of_cables);
      console.log(collections);
    }
    return collections;
  }

  function startUpLoadData(cables) {
    var dirtyReportHandler = cables;

    const cleanReportHandler = (report) => {
      const uniqueTicketNames = new Set();
      const filteredCombinedCableNames = [];
      report.combinedCableNames.forEach((cable) => {
        if (!uniqueTicketNames.has(cable.ticketName)) {
          uniqueTicketNames.add(cable.ticketName);
          filteredCombinedCableNames.push(cable);
        }
      });

      return filteredCombinedCableNames; // prob be used for future reference
    };
    cleanReport = cleanReportHandler(dirtyReportHandler);
  }

  function setMonthOrYear(month, year) {
    globalSelectedMonth = month;
    globalSelectedYear = year;
  }

  function setArrayOfDates(selectedDates) {
    globalSelectedDates = [] // ensure the global dates is empty
    globalSelectedDates = selectedDates;
  }


  // Checker para dili sakit sa mata once mag debug
  function incidentTypeChecker(cable) {
    for (var i = 0; i < cable.length; i++) {
      if (cable[i].incidentType.toString() == "Outage") locationChecker(cable[i], 0);
      else locationChecker(cable[i], 1);
    }

  }
  // pwede rani sila ma isa pero hahaha

  function locationChecker(cable, index) {
    var cable_name = cable.combinedName.split(" ");
    let collectionIndex = 0;

    for (const item of collections) {
      if (item.cableName === cable_name[0]) {
        if (cable.location.toLowerCase().includes('dry')) {
          collections[collectionIndex].incidentType[index][0].dry.push(cable)
        }
        if (cable.location.toLowerCase().includes('wet')) {
          collections[collectionIndex].incidentType[index][0].dry.push(cable)
        }
        if (cable.location.toLowerCase().includes('undetermined')) {
          collections[collectionIndex].incidentType[index][0].dry.push(cable)
        }
        if (cable.location.toLowerCase().includes('backhaul')) {
          collections[collectionIndex].incidentType[index][0].dry.push(cable)
        }
        collectionIndex = 0;
        break;
      }
      else {
        collectionIndex++;
        continue;
      }
    }
  }
  function clearCollections(collections) {
    collections.forEach((collection) => {
      collection.incidentType.forEach((incidentArray) => {
        incidentArray.forEach((incidentType) => {
          incidentType.dry = [];
          incidentType.wet = [];
          incidentType.under = [];
          incidentType.back = [];
        });
      });
    });
    globalSelectedDates = [];
  }

  function collectAllTicketsForEachCable(collections) {
    const allTickets = {};

    collections.forEach((collection) => {
      const cableName = collection.cableName;
      const tickets = [];

      // Loop through incident types (Outage, Other) and collect tickets
      collection.incidentType.forEach((incidentArray) => {
        incidentArray.forEach((incidentType) => {
          // Collect tickets from each category (dry, wet, under, back)
          tickets.push(...incidentType.dry);
          tickets.push(...incidentType.wet);
          tickets.push(...incidentType.under);
          tickets.push(...incidentType.back);
        });
      });

      // Assign the collected tickets to the corresponding cableName
      allTickets[cableName] = tickets;
    });

    return allTickets;
  }

  function generateTotalReportedSegments(collections) {
    const totalSegments = {};

    collections.forEach((collection) => {
      const cableName = collection.cableName;

      // Initialize the count object for each cable system
      totalSegments[cableName] = {
        dry: 0,
        wet: 0,
        under: 0,
        back: 0
      };

      // Loop through incident types (Outage, Other) and aggregate counts
      collection.incidentType.forEach((incidentArray) => {
        incidentArray.forEach((incidentType) => {
          totalSegments[cableName].dry += incidentType.dry.length;
          totalSegments[cableName].wet += incidentType.wet.length;
          totalSegments[cableName].under += incidentType.under.length;
          totalSegments[cableName].back += incidentType.back.length;
        });
      });
    });

    return totalSegments;
  }

  function incidentType(collections) {
    const totalIncident = {};

    collections.forEach((collection) => {
      const cableName = collection.cableName;

      // Initialize the count object for each cable system
      totalIncident[cableName] = {
        Outage: 0,
        Planned: 0
      };

      // Loop through incident types and count Outage and Planned incidents
      collection.incidentType.forEach((incidentArray) => {
        incidentArray.forEach((incidentType, index) => {
          if (index === 0) {
            // Index 0 corresponds to 'Outage'
            totalIncident[cableName].Outage += incidentType.dry.length;
            totalIncident[cableName].Outage += incidentType.wet.length;
            totalIncident[cableName].Outage += incidentType.under.length;
            totalIncident[cableName].Outage += incidentType.back.length;
          } else if (index === 1) {
            // Index 1 corresponds to 'Planned'
            totalIncident[cableName].Planned += incidentType.dry.length;
            totalIncident[cableName].Planned += incidentType.wet.length;
            totalIncident[cableName].Planned += incidentType.under.length;
            totalIncident[cableName].Planned += incidentType.back.length;
          }
        });
      });
    });

    return totalIncident;
  }



  function totalReportedSegments(collections) {

  }

  document.addEventListener('DOMContentLoaded', () => {
    const options = {
      settings: {
        range: {
          disableGaps: true,
        },
        selection: {
          day: "multiple-ranged"
        },
        visibility: {
          weekNumbers: true,
          theme: 'light'
        }
      },
      actions: {
        clickYear(event, self) {
          self.settings.selected.dates = [];
          self.update({ dates: true });
          clearCollections(collections);
          setMonthOrYear(self.selectedMonth, self.selectedYear);
          getReport(cleanReport);
        },
        clickMonth(event, self) {
          self.settings.selected.dates = [];
          self.update({ dates: true });
          clearCollections(collections);
          setMonthOrYear(self.selectedMonth, self.selectedYear);
          getReport(cleanReport);
        },
        clickArrow(event, self) {
          self.settings.selected.dates = [];
          self.update({ dates: true });
          clearCollections(collections);
          setMonthOrYear(self.selectedMonth, self.selectedYear);
          getReport(cleanReport);
        },
        /*
          Don't get confused if it says Day. this part is configured to be only in weeks
          vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        */
        clickDay(event, self) {
          if (self.selectedDates.length == 1) {
            return null;
          }
          else if (self.selectedDates[0] === undefined && self.selectedDates[1] === undefined) {
            return null;
          }
          else {
            clearCollections(collections);
            setArrayOfDates(self.selectedDates);
            getReport(cleanReport);
          }
        },
        //for clicking the week number
        clickWeekNumber(event, number, days, year, self) {
          clearCollections(collections);
          self.settings.selected.dates = days.map(day => day.dataset.calendarDay)
          self.update({ dates: true })
          setArrayOfDates(self.selectedDates);
          getReport(cleanReport);

        }
      },
    }

    const calendar = new VanillaCalendar("#calendar", options)
    calendar.init()
  });
</script>
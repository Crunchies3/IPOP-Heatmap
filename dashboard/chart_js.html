<!-- for charts -->
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Pie chart incident type
        var pieChart = echarts.init(document.getElementById('pie-chart'));
        pieChart.setOption({
            color: ['#ff5858', '#A6C5F7', '#D2DDEC'],
            tooltip: { trigger: 'item' },
            legend: { bottom: '8%', left: 'center' },
            series: [{
                type: 'pie',
                radius: ['40%', '55%'],
                avoidLabelOverlap: false,
                label: { show: false, position: 'center' },
                labelLine: { show: false },
                data: [
                    { value: 1048, name: 'Outage' },
                    { value: 735, name: 'Planned Activity' }
                ]
            }]
        });

        // Bar chart segment fault
        var segmentBarChart = echarts.init(document.getElementById('segment-bar-chart'));
        segmentBarChart.setOption({
            color: ['#155ebf', '#2C7BE5', '#A6C5F7', '#D2DDEC'],
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'shadow' }
            },
            legend: {},
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: { data: ['SEA-US', 'SJC', 'C2C', 'EAC', 'TGN-IA/P'] },
            yAxis: {},
            series: [
                { name: 'Dry Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [320, 302, 301, 334, 390] },
                { name: 'Wet Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [120, 132, 101, 134, 90] },
                { name: 'Undetermined', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [220, 182, 191, 234, 290] },
                { name: 'Backhaul', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [150, 212, 201, 154, 190] }
            ]
        });

        // Incident bar chart
        var incidentBarChart = echarts.init(document.getElementById('incident-bar-chart'));
        incidentBarChart.setOption({
            color: ['#ff5858', '#A6C5F7'],
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'shadow' }
            },
            legend: {},
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: { data: ['SEA-US', 'SJC', 'C2C', 'EAC', 'TGN-IA/P'] },
            yAxis: {},
            series: [
                { name: 'Outage', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [120, 132, 101, 134, 90] },
                { name: 'Planned Activity', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [320, 302, 301, 334, 390] }
            ]
        });

        // Yearly tickets line chart
        var yearlyLineChart = echarts.init(document.getElementById('yearly-line-graph'));
        yearlyLineChart.setOption({
            tooltip: { trigger: 'axis' },
            legend: { data: ['SEA-US', 'SJC', 'C2C', 'EAC', 'TGN-IA/P'] },
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            toolbox: { feature: { saveAsImage: {} } },
            xAxis: {
                type: 'category',
                boundaryGap: false,
                data: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
            },
            yAxis: { type: 'value' },
            series: [
                { name: 'SEA-US', type: 'line', data: [78, 162, 94, 140, 55, 187, 123, 82, 149, 71, 198, 108], emphasis: { focus: 'series' } },
                { name: 'SJC', type: 'line', data: [134, 76, 189, 63, 95, 144, 182, 112, 153, 67, 125, 192], emphasis: { focus: 'series' } },
                { name: 'C2C', type: 'line', data: [158, 72, 142, 99, 186, 54, 135, 178, 81, 147, 162, 105], emphasis: { focus: 'series' } },
                { name: 'EAC', type: 'line', data: [90, 177, 68, 121, 159, 50, 130, 84, 196, 73, 141, 111], emphasis: { focus: 'series' } },
                { name: 'TGN-IA/P', type: 'line', data: [118, 67, 159, 84, 142, 93, 177, 53, 135, 101, 168, 190], emphasis: { focus: 'series' } }
            ]
        });

        // Root cause bar chart
        var rootCauseBarChart = echarts.init(document.getElementById('root-cause-bar'));
        rootCauseBarChart.setOption({
            color: ['#155ebf', '#2C7BE5', '#A6C5F7', '#D2DDEC'],
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'shadow' }
            },
            legend: {},
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: {
                data: ['BMH Issue', 'Cable Fault', 'Card Failure', 'Configuration Issue', 'Force Majeure', 'Planned Maintenance', 'Shunt Fault', 'Subsea Equipment Fault', 'Unknown']
            },
            yAxis: {},
            series: [
                { name: 'Dry Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [10, 22, 28, 43, 49, 10, 29, 10, 20] },
                { name: 'Wet Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [10, 22, 28, 43, 49, 10, 29, 10, 20] },
                { name: 'Undetermined', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [10, 22, 28, 43, 49, 10, 29, 10, 20] },
                { name: 'Backhaul', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [10, 22, 28, 43, 49, 10, 29, 10, 20] }
            ]
        });
    });
</script>

<!-- for calendar -->
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const options = {
            settings: {
                range: {
                    disableGaps: true,
                },
                selection: {
                    day: "multiple-ranged"
                },
                visibility: {
                    weekNumbers: true,
                    theme: 'light'
                }
            },
            actions: {
                clickYear(event, self) {
                    self.settings.selected.dates = [];
                    self.update({ dates: true });
                    clearCollections(collections);
                    setMonthOrYear(self.selectedMonth, self.selectedYear);
                    getReport(cleanReport);
                },
                clickMonth(event, self) {
                    self.settings.selected.dates = [];
                    self.update({ dates: true });
                    clearCollections(collections);
                    setMonthOrYear(self.selectedMonth, self.selectedYear);
                    getReport(cleanReport);
                },
                clickArrow(event, self) {
                    self.settings.selected.dates = [];
                    self.update({ dates: true });
                    clearCollections(collections);
                    setMonthOrYear(self.selectedMonth, self.selectedYear);
                    getReport(cleanReport);
                },
                /*
                Don't get confused if it says Day. this part is configured to be only in weeks
                vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
                */
                clickDay(event, self) {
                    if (self.selectedDates.length == 1) {
                        return null;
                    }
                    else if (self.selectedDates[0] === undefined && self.selectedDates[1] === undefined) {
                        return null;
                    }
                    else {
                        clearCollections(collections);
                        setArrayOfDates(self.selectedDates);
                        getReport(cleanReport);
                    }
                },
                //for clicking the week number
                clickWeekNumber(event, number, days, year, self) {
                    clearCollections(collections);
                    self.settings.selected.dates = days.map(day => day.dataset.calendarDay)
                    self.update({ dates: true })
                    setArrayOfDates(self.selectedDates);
                    getReport(cleanReport);

                }
            },
        }

        const calendar = new VanillaCalendar("#calendar", options)
        calendar.init()
    });
</script>

<!-- for functions -->
<script>
    window.onload = (event) => {
        //load every data to a array
        google.script.run.withSuccessHandler(startUpLoadData).getCableNames()
    }

    var cleanReport;
    var globalSelectedDates = [];
    var globalSelectedYear = new Date().getFullYear();
    var globalSelectedMonth = new Date().getMonth();
    //TODO Make a Collection --- sa papel ani ang flow--- OBJECT - ARRAY - OBJECT - ARRAY
    var collections = [{
        cableName: 'SEAUS',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'SJC',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'C2C',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'EAC',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'TGN',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    }]; // Collections that will show in the graph
    //Initialized para dili labad mag debug


    function getReport(cables) {
        var box_of_cables = []
        if (globalSelectedDates.length > 1) {
            for (let i = 0; i < cables.length; i++) {
                if (new Date(cables[i].startDate).setHours(0, 0, 0, 0) >= new Date(globalSelectedDates[0]).setHours(0, 0, 0, 0) && new Date(cables[i].startDate).setHours(0, 0, 0, 0) <= new Date(globalSelectedDates[globalSelectedDates.length - 1]).setHours(0, 0, 0, 0)) {
                    box_of_cables.push(cables[i]);
                }
            }
            incidentTypeChecker(box_of_cables)
            console.log(collections);
        }
        else {
            cables.forEach(element => {
                if (new Date(element.startDate).getMonth() == globalSelectedMonth && new Date(element.startDate).getFullYear() == globalSelectedYear) { // added one cuz 1st month starts at 0
                    box_of_cables.push(element)
                }
            });
            incidentTypeChecker(box_of_cables);
            console.log(collections);
        }
        return collections;
    }

    function startUpLoadData(cables) {
        var dirtyReportHandler = cables;

        const cleanReportHandler = (cables) => {
            const uniqueTicketNames = new Set();
            const filteredCombinedCableNames = [];
            cables.combinedCableNames.forEach((cable) => {
                if (!uniqueTicketNames.has(cable.ticketName)) {
                    uniqueTicketNames.add(cable.ticketName);
                    filteredCombinedCableNames.push(cable);
                }
            });

            return filteredCombinedCableNames;
        };

        cleanReport = cleanReportHandler(dirtyReportHandler);

        getReport(cleanReport);

    }

    function setMonthOrYear(month, year) {
        globalSelectedMonth = month;
        globalSelectedYear = year;
    }

    function setArrayOfDates(selectedDates) {
        globalSelectedDates = [] // ensure the global dates is empty
        globalSelectedDates = selectedDates;
    }


    // Checker para dili sakit sa mata once mag debug
    function incidentTypeChecker(cable) {
        for (var i = 0; i < cable.length; i++) {
            if (cable[i].incidentType.toString() == "Outage") locationChecker(cable[i], 0);
            else locationChecker(cable[i], 1);
        }

    }
    // pwede rani sila ma isa pero hahaha

    function locationChecker(cable, index) {
        var cable_name = cable.combinedName.split(" ");
        let collectionIndex = 0;

        for (const item of collections) {
            if (item.cableName === cable_name[0]) {
                if (cable.location.toLowerCase().includes('dry')) {
                    collections[collectionIndex].incidentType[index][0].dry.push(cable)
                }
                if (cable.location.toLowerCase().includes('wet')) {
                    collections[collectionIndex].incidentType[index][0].dry.push(cable)
                }
                if (cable.location.toLowerCase().includes('undetermined')) {
                    collections[collectionIndex].incidentType[index][0].dry.push(cable)
                }
                if (cable.location.toLowerCase().includes('backhaul')) {
                    collections[collectionIndex].incidentType[index][0].dry.push(cable)
                }
                collectionIndex = 0;
                break;
            }
            else {
                collectionIndex++;
                continue;
            }
        }
    }
    function clearCollections(collections) {
        collections.forEach((collection) => {
            collection.incidentType.forEach((incidentArray) => {
                incidentArray.forEach((incidentType) => {
                    incidentType.dry = [];
                    incidentType.wet = [];
                    incidentType.under = [];
                    incidentType.back = [];
                });
            });
        });
        globalSelectedDates = [];
    }

    function collectAllTicketsForEachCable(collections) {
        const allTickets = {};

        collections.forEach((collection) => {
            const cableName = collection.cableName;
            const tickets = [];

            // Loop through incident types (Outage, Other) and collect tickets
            collection.incidentType.forEach((incidentArray) => {
                incidentArray.forEach((incidentType) => {
                    // Collect tickets from each category (dry, wet, under, back)
                    tickets.push(...incidentType.dry);
                    tickets.push(...incidentType.wet);
                    tickets.push(...incidentType.under);
                    tickets.push(...incidentType.back);
                });
            });

            // Assign the collected tickets to the corresponding cableName
            allTickets[cableName] = tickets;
        });

        return allTickets;
    }

    function generateTotalReportedSegments(collections) {
        const totalSegments = {};

        collections.forEach((collection) => {
            const cableName = collection.cableName;

            // Initialize the count object for each cable system
            totalSegments[cableName] = {
                dry: 0,
                wet: 0,
                under: 0,
                back: 0
            };

            // Loop through incident types (Outage, Other) and aggregate counts
            collection.incidentType.forEach((incidentArray) => {
                incidentArray.forEach((incidentType) => {
                    totalSegments[cableName].dry += incidentType.dry.length;
                    totalSegments[cableName].wet += incidentType.wet.length;
                    totalSegments[cableName].under += incidentType.under.length;
                    totalSegments[cableName].back += incidentType.back.length;
                });
            });
        });

        // Transform data into the format expected by ECharts
        return {
            xAxisData: Object.keys(totalSegments),
            seriesData: [
                { name: 'Dry Segment', data: Object.values(totalSegments).map(segment => segment.dry) },
                { name: 'Wet Segment', data: Object.values(totalSegments).map(segment => segment.wet) },
                { name: 'Undetermined', data: Object.values(totalSegments).map(segment => segment.under) },
                { name: 'Backhaul', data: Object.values(totalSegments).map(segment => segment.back) }
            ]
        };
    }

    function incidentType(collections) {
        const totalIncident = {};

        collections.forEach((collection) => {
            const cableName = collection.cableName;

            // Initialize the count object for each cable system
            totalIncident[cableName] = {
                Outage: 0,
                Planned: 0
            };

            // Loop through incident types and count Outage and Planned incidents
            collection.incidentType.forEach((incidentArray) => {
                incidentArray.forEach((incidentType, index) => {
                    if (index === 0) {
                        // Index 0 corresponds to 'Outage'
                        totalIncident[cableName].Outage += incidentType.dry.length;
                        totalIncident[cableName].Outage += incidentType.wet.length;
                        totalIncident[cableName].Outage += incidentType.under.length;
                        totalIncident[cableName].Outage += incidentType.back.length;
                    } else if (index === 1) {
                        // Index 1 corresponds to 'Planned'
                        totalIncident[cableName].Planned += incidentType.dry.length;
                        totalIncident[cableName].Planned += incidentType.wet.length;
                        totalIncident[cableName].Planned += incidentType.under.length;
                        totalIncident[cableName].Planned += incidentType.back.length;
                    }
                });
            });
        });

        return totalIncident;
    }

</script>
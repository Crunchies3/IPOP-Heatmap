<script>
    var notifiedCables; // will hold the data about the notified cable maintenance/etc. will be use for forecasting status of the cables.
    var cablePaths;
    var searchTerm;

    if (!map) {
        var bounds = L.latLngBounds([[90, -70], [-90, 310]]);

        map = L.map('map', {
            maxZoom: 18,
            minZoom: 3,
            dragging: true,
            maxBounds: bounds,
            zoomSnap: 0.5,
            center: [8.345422, 158.581226],
            zoom: 3
        });

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a ></a> K.Y.L.C',
            language: 'en',
        }).addTo(map);


        // Layer groups used for filtering
        var sjc = L.layerGroup().addTo(map);
        var c2c = L.layerGroup().addTo(map);
        var tgn = L.layerGroup().addTo(map);
        var seaus = L.layerGroup().addTo(map);
        var eac = L.layerGroup().addTo(map);
    }


    // Function to add markers to the map
    function addMarkers(locations) {
        locations.forEach(function (location) {
            var pointIcon = L.divIcon({
                className: 'point-icon', // CSS class for styling
                html: '<div class="point-marker"></div>', // HTML for the point symbol
                iconAnchor: [3, 3], // Center the marker at the coordinates

            });

            L.marker([location.longitude, location.latitude], { icon: pointIcon }).addTo(map).bindPopup(location.pointName);
        });
    }

    // Fetch locations from Google Sheets and add markers
    google.script.run.withSuccessHandler(addMarkers).getSJCLocations();

    function addPolylines(cables) {
        let date = new Date();

        // Fetch cable names from Google Sheets using Google Apps Script
        google.script.run.withSuccessHandler(function (data) {

            cables.forEach(function (cable) {
                var latitudeFrom = parseFloat(cable.latitudeFrom);
                var longitudeFrom = parseFloat(cable.longitudeFrom);
                var latitudeTo = parseFloat(cable.latitudeTo);
                var longitudeTo = parseFloat(cable.longitudeTo);
                var cableName = cable.cableName.trim(); // Convert cable name to uppercase for case-insensitive comparison

                // Check if parsed values are valid numbers
                if (isNaN(latitudeFrom) || isNaN(longitudeFrom) || isNaN(latitudeTo) || isNaN(longitudeTo)) {
                    return; // Skip this cable if coordinates are invalid
                }

                var coordinates = [
                    [longitudeFrom, latitudeFrom],
                    [longitudeTo, latitudeTo]
                ];


                var type = getCableType(cableName);

                var color = "green";
                var polyline = L.polyline(coordinates, { color: color, weight: 2 }).bindPopup(cable.cableName);
                polylines[type][cable.cableName] = polyline;
                polyline.addTo(polylines[type].group || (type === 'SJC' ? sjc : type === 'C2C' ? c2c : type === 'TGN' ? tgn : type === 'EAC' ? eac : seaus));
            });


            data.combinedCableNames.forEach(cables => {
                let color = "green";
                let cable_name = cables.combinedName.trim();

                var type = getCableType(cable_name);

                let notifiedDate = parseDate(cables.notifiedDate);
                let startDate = parseDate(cables.startDate);
                let endDate = parseDate(cables.endDate);
                if (date >= startDate && date <= endDate) color = 'red';
                if (date < startDate && date >= notifiedDate) color = 'yellow';

                updatePolylineColor(type, cable_name, color);
            });


            console.log("polyline data structure");
            console.log(polylines);



        }).getCableNames();
    }



    function getCableType(cable_type) {
        var type;
        if (cable_type.includes('SJC')) type = "SJC";
        else if (cable_type.includes('EAC')) type = "EAC";
        else if (cable_type.includes('C2C')) type = "C2C";
        else if (cable_type.includes('SEAUS')) type = "SEAUS";
        else if (cable_type.includes('TGN')) type = "TGN";
        return type;
    }

    // ======================================<<START>>=================================

    function changePolylineColor(rangeIndex) {
        // Get the string date from the element
        const stringDate = getDateFromElement(rangeIndex);

        console.log("current date: " + stringDate);

        // Get cable data
        const cableData = getCableData(notifiedCables);

        console.log("notified cables");
        console.log(cableData);

        cableData.forEach(cable => {
            // Determine the color based on the date and cable information
            const color = determineColor(stringDate, cable);

            console.log("color: " + color);

            // Construct the polyline IDs based on cable system and segments
            const polylineIds = [
                `${cable.cableSystem} ${cable.segment1}`,
                `${cable.segment2 ? `${cable.cableSystem} ${cable.segment2}` : ''}`,
                `${cable.segment3 ? `${cable.cableSystem} ${cable.segment3}` : ''}`
            ];

            console.log("polyline ids");
            console.log(polylineIds);

            var type = getCableType(cable.cableSystem);

            console.log("type: " + type);


            // Update color for each polyline ID
            polylineIds.forEach(polylineId => {
                if (polylineId) {
                    updateCablePaths(polylineId, color, type);
                }
            });
        });
    }


    function changePolylineColorViaDatePicker(stringDate) {
        // Get cable data
        const cableData = getCableData(notifiedCables);

        cableData.forEach(cable => {
            // Determine the color based on the date and cable information
            const color = determineColor(stringDate, cable);

            // Construct the polyline IDs based on cable system and segments
            const polylineIds = [
                `${cable.cableSystem} ${cable.segment1}`,
                `${cable.segment2 ? `${cable.cableSystem} ${cable.segment2}` : ''}`,
                `${cable.segment3 ? `${cable.cableSystem} ${cable.segment3}` : ''}`
            ];

            // Update color for each polyline ID
            polylineIds.forEach(polylineId => {
                if (polylineId) {
                    updateCablePaths(polylineId, color, type);
                }
            });
        });
    }

    function updateCablePaths(polylineId, color, type) {
        // Find the corresponding cable path
        const cablePath = cablePaths.find(path => path.value === polylineId);

        if (cablePath) {
            // Collect all non-empty paths
            const pathsToUpdate = [];
            for (let i = 1; i < 7; i++) {
                const pathKey = `path${i}`;
                if (cablePath[pathKey] && cablePath[pathKey] !== "") {
                    pathsToUpdate.push(cablePath[pathKey]);
                }
            }

            console.log("path to updates");
            console.log(pathsToUpdate);

            // Update the color for each path
            pathsToUpdate.forEach(path => {
                updatePolylineColor(type, path, color);
            });
        } else {
            // Optionally handle the case where no paths are found
            console.log("path to updates (polyline id)");
            console.log(polylineId);
            updatePolylineColor(type, polylineId, color);
        }
    }

    function getDateFromElement(rangeIndex) {
        return document.getElementById(parseInt(rangeIndex) + 1).value;
    }

    function getCableData(data) {
        return data.map(([cableSystem, notifiedDate, startDate, endDate, segment1, segment2, segment3]) => ({
            cableSystem,
            notifiedDate,
            startDate,
            endDate,
            segment1,
            segment2,
            segment3
        }));
    }

    function determineColor(stringDate, cable) {
        const date = parseDate(stringDate);
        const startDate = parseDate(cable.startDate);
        const endDate = parseDate(cable.endDate);
        const notifiedDate = parseDate(cable.notifiedDate);

        if (date >= startDate && date <= endDate) return 'red';
        if (date < startDate && date >= notifiedDate) return 'yellow';
        return 'green';
    }

    function updatePolylineColor(type, id, newColor) {

        if (polylines[type] && polylines[type][id]) {
            polylines[type][id].setStyle({ color: newColor });
        } else {
            console.error('Polyline not found:', type, id);
        }
    }

    function parseDate(dateStr) {
        return new Date(dateStr);
    }
    // ======================================<<END>>=================================


    function getNotifiedCableData(data) {
        console.log("notified cables data");
        console.log(data);
        notifiedCables = data;
    }

    function getAllCablePaths(paths) {
        cablePaths = paths;
    }

    function initializeMap() {
        console.log('refreshing shenanigans');
        google.script.run.withSuccessHandler(addMarkers).getSJCLocations();
        google.script.run.withSuccessHandler(addPolylines).getSJCData();
        searchCableSystem();
        google.script.run.withSuccessHandler(getNotifiedCableData).extractDates(searchTerm);
        google.script.run.withSuccessHandler(getAllCablePaths).getFullPaths();
        google.script.run.withSuccessHandler().transferNotifToStartandEndDate();
    }

    // Call the initializeMap function when the page loads
    window.onload = initializeMap;
    window.onload = startAutoRefresh;


    function startAutoRefresh() {
        initializeMap(); // Call immediately on load
        setInterval(initializeMap, 1 * 60 * 1000); // Repeat every 1 minute
    }


    // Function to search for a cable system and filter the cables accordingly
    function searchCableSystem() {
        searchTerm = document.getElementById("search-input").value;

        let type = convertSearchTerm(searchTerm);

        if (type != "ALL") {

            map.eachLayer(function (layer) {
                if (layer instanceof L.Polyline) {
                    map.removeLayer(layer);
                }
            });

            Object.values(polylines[type]).forEach(function (polyline) {
                polyline.addTo(map);
            });

        } else {
            map.eachLayer(function (layer) {
                if (layer instanceof L.Polyline) {
                    map.removeLayer(layer);
                }
            });

            Object.values(polylines).forEach(function (group) {
                Object.values(group).forEach(function (polyline) {
                    polyline.addTo(map);
                });
            });
        }


        // Very important. will be used in extracting dates
        if (searchTerm === "Show All Cable Systems") searchTerm = "All";
        else if (searchTerm === "SEA-US") searchTerm = "SEAUS";
        else if (searchTerm === "SJC") searchTerm = "SJC";
        else if (searchTerm === "EAC") searchTerm = "EAC";
        else if (searchTerm === "C2C") searchTerm = "C2C";
        else if (searchTerm === "TGN-IA/TGN-P") searchTerm = "TGN-IA/TGN-P";
    }

    // Function to set the opacity of all cables on the map
    function setAllCablesOpacity(opacity) {
        map.eachLayer(function (layer) {
            if (layer instanceof L.Polyline) {
                layer.setStyle({ opacity: opacity });
            }
        });
    }

    function convertSearchTerm(searchTerm) {
        if (searchTerm === "Show All Cable Systems") return "ALL";
        else if (searchTerm === "TGN-IA/TGN-P") return "TGN";
        else return searchTerm;
    }

</script>
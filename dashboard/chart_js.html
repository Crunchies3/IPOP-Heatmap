<!-- for charts -->
<script>
    window.onload = (event) => {
        //load every data to a array
        showSpinner();
        google.script.run.withSuccessHandler(startUpLoadData).getAllCableNames();

    }

    // Function to show the spinner
    function showSpinner() {
        document.getElementById('spinnerModal').style.display = 'block';
    }

    // Function to hide the spinner
    function hideSpinner() {
        document.getElementById('spinnerModal').style.display = 'none';
    }

    // Example of showing spinner while loading data
    function ticketsCreatedDisplay() {
        document.getElementById('sea-us').innerText = collectAllTicketsForEachCable()['SEAUS'].length;
        document.getElementById('sjc').innerText = collectAllTicketsForEachCable()['SJC'].length;
        document.getElementById('c2c').innerText = collectAllTicketsForEachCable()['C2C'].length;
        document.getElementById('eac').innerText = collectAllTicketsForEachCable()['EAC'].length;
        document.getElementById('tgn').innerText = collectAllTicketsForEachCable()['TGN'].length;
        document.getElementById('totalticketDOM').innerText = collectAllTicketsForEachCable()['SEAUS'].length + collectAllTicketsForEachCable()['SJC'].length +
            collectAllTicketsForEachCable()['C2C'].length + collectAllTicketsForEachCable()['EAC'].length + collectAllTicketsForEachCable()['TGN'].length
    }

    function loadChart() {
        ticketsCreatedDisplay();
        // Pie chart incident type
        var pieChart = echarts.init(document.getElementById('pie-chart'));
        pieChart.setOption({
            color: ['#ff5858', '#A6C5F7', '#D2DDEC'],
            tooltip: { trigger: 'item' },
            legend: { bottom: '8%', left: 'center' },
            series: [{
                type: 'pie',
                radius: ['40%', '55%'],
                avoidLabelOverlap: false,
                label: { show: false, position: 'center' },
                labelLine: { show: false },
                data: [
                    { value: incidentType()['SEAUS'].Outage + incidentType()['C2C'].Outage + incidentType()['TGN'].Outage + incidentType()['SJC'].Outage + incidentType()['EAC'].Outage, name: 'Outage' },
                    { value: incidentType()['SEAUS'].Planned + incidentType()['C2C'].Planned + incidentType()['TGN'].Planned + incidentType()['SJC'].Planned + incidentType()['EAC'].Planned, name: 'Planned Activity' }
                ]
            }]
        });

        // Bar chart segment fault
        var segmentBarChart = echarts.init(document.getElementById('segment-bar-chart'));
        segmentBarChart.setOption({
            color: ['#155ebf', '#2C7BE5', '#A6C5F7', '#D2DDEC'],
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'shadow' }
            },
            legend: {},
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: { data: ['SEA-US', 'SJC', 'C2C', 'EAC', 'TGN-IA/P'] },
            yAxis: {},
            series: [
                { name: 'Dry Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [generateTotalReportedSegments()['SEAUS'].dry, generateTotalReportedSegments()['SJC'].dry, generateTotalReportedSegments()['C2C'].dry, generateTotalReportedSegments()['EAC'].dry, generateTotalReportedSegments()['TGN'].dry] },
                { name: 'Wet Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [generateTotalReportedSegments()['SEAUS'].wet, generateTotalReportedSegments()['SJC'].wet, generateTotalReportedSegments()['C2C'].wet, generateTotalReportedSegments()['EAC'].wet, generateTotalReportedSegments()['TGN'].wet] },
                { name: 'Undetermined', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [generateTotalReportedSegments()['SEAUS'].under, generateTotalReportedSegments()['SJC'].under, generateTotalReportedSegments()['C2C'].under, generateTotalReportedSegments()['EAC'].under, generateTotalReportedSegments()['TGN'].under] },
                { name: 'Backhaul', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [generateTotalReportedSegments()['SEAUS'].back, generateTotalReportedSegments()['SJC'].back, generateTotalReportedSegments()['C2C'].back, generateTotalReportedSegments()['EAC'].back, generateTotalReportedSegments()['TGN'].back] }
            ]
        });

        // Incident bar chart
        var incidentBarChart = echarts.init(document.getElementById('incident-bar-chart'));
        incidentBarChart.setOption({
            color: ['#ff5858', '#A6C5F7'],
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'shadow' }
            },
            legend: {},
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: { data: ['SEA-US', 'SJC', 'C2C', 'EAC', 'TGN-IA/P'] },
            yAxis: {},
            series: [
                { name: 'Outage', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [incidentType()['SEAUS'].Outage, incidentType()['SJC'].Outage, incidentType()['C2C'].Outage, incidentType()['EAC'].Outage, incidentType()['TGN'].Outage] },
                { name: 'Planned Activity', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [incidentType()['SEAUS'].Planned, incidentType()['SJC'].Planned, incidentType()['C2C'].Planned, incidentType()['EAC'].Planned, incidentType()['TGN'].Planned] }
            ]
        });

        // Yearly tickets line chart
        var yearlyLineChart = echarts.init(document.getElementById('yearly-line-graph'));
        yearlyLineChart.setOption({
            tooltip: { trigger: 'axis' },
            legend: { data: ['SEA-US', 'SJC', 'C2C', 'EAC', 'TGN-IA/P'] },
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            toolbox: { feature: { saveAsImage: {} } },
            xAxis: {
                type: 'category',
                boundaryGap: false,
                data: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
            },
            yAxis: { type: 'value' },
            series: [
                { name: 'SEA-US', type: 'line', data: getCableYearlyReportToGraph().SEAUS, emphasis: { focus: 'series' } },
                { name: 'SJC', type: 'line', data: getCableYearlyReportToGraph().SJC, emphasis: { focus: 'series' } },
                { name: 'C2C', type: 'line', data: getCableYearlyReportToGraph().C2C, emphasis: { focus: 'series' } },
                { name: 'EAC', type: 'line', data: getCableYearlyReportToGraph().EAC, emphasis: { focus: 'series' } },
                { name: 'TGN-IA/P', type: 'line', data: getCableYearlyReportToGraph().TGN, emphasis: { focus: 'series' } }
            ]
        });

        // Root cause bar chart
        var rootCauseBarChart = echarts.init(document.getElementById('root-cause-bar'));
        rootCauseBarChart.setOption({
            color: ['#155ebf', '#2C7BE5', '#A6C5F7', '#D2DDEC'],
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'shadow' }
            },
            legend: {},
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: {
                data: ['BMH Issue', 'Cable Fault', 'Card Failure', 'Configuration Issue',
                    'Fan Issue', 'Force Majeure', 'Government/Private Project', 'Human Error',
                    'PFE Issue', 'Physical Connection', 'Planned Maintenance', 'Shunt Fault',
                    'Subsea Equipment Fault', 'Unknown']
            },
            yAxis: {},
            series: [
                { name: 'Dry Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: generateTotalRootCause('dry') },
                { name: 'Wet Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: generateTotalRootCause('wet') },
                { name: 'Undetermined', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: generateTotalRootCause('under') },
                { name: 'Backhaul', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: generateTotalRootCause('back') }
            ]
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
        const options = {
            settings: {
                range: {
                    disableGaps: true,
                },
                selection: {
                    day: "multiple-ranged"
                },
                visibility: {
                    weekNumbers: true,
                    theme: 'light'
                }
            },
            actions: {
                clickYear(event, self) {
                    // self.settings.selected.dates = [];
                    // self.update({ dates: true });
                    clearCollections();
                    isYear = true;
                    setYear(self.selectedYear);
                    getReport(cleanReport);
                    loadChart();
                    document.getElementById('reportType').innerText = 'Yearly'
                },
                clickMonth(event, self) {
                    // self.settings.selected.dates = [];
                    // self.update({ dates: true });
                    clearCollections();
                    setMonthOrYear(self.selectedMonth, self.selectedYear);
                    isYear = false;
                    getReport(cleanReport);
                    loadChart();
                    document.getElementById('reportType').innerText = 'Monthly'
                },
                clickArrow(event, self) {
                    // self.settings.selected.dates = [];
                    // self.update({ dates: true });
                    clearCollections();
                    setMonthOrYear(self.selectedMonth, self.selectedYear);
                    isYear = false;
                    getReport(cleanReport);
                    loadChart();
                    document.getElementById('reportType').innerText = 'Monthly'
                },
                /*
                Don't get confused if it says Day. this part is configured to be only in weeks
                vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
                */
                clickDay(event, self) {
                    if (self.selectedDates.length == 1) {
                        clearCollections();
                        setMonthOrYear(self.selectedMonth, self.selectedYear);
                        isYear = false;
                        getReport(cleanReport);
                        loadChart();
                        document.getElementById('reportType').innerText = 'Monthly'
                    }
                    else if (self.selectedDates[0] === undefined && self.selectedDates[1] === undefined) {
                        clearCollections();
                        setMonthOrYear(self.selectedMonth, self.selectedYear);
                        isYear = false;
                        getReport(cleanReport);
                        loadChart();
                        document.getElementById('reportType').innerText = 'Monthly'
                    }
                    else {
                        clearCollections();
                        setArrayOfDates(self.selectedDates);
                        isYear = false;
                        getReport(cleanReport);
                        loadChart();
                        document.getElementById('reportType').innerText = 'Custom Range'
                    }
                },
                //for clicking the week number
                clickWeekNumber(event, number, days, year, self) {
                    if (weekTriggered == true && globalWeekNumber == number) {
                        weekTriggered = false;
                        self.settings.selected.dates = [];
                        self.update({ dates: true })
                        clearCollections();
                        setMonthOrYear(self.selectedMonth, self.selectedYear);
                        isYear = false;
                        getReport(cleanReport);
                        loadChart();
                        setClickWeekNumber(number);
                        document.getElementById('reportType').innerText = 'Monthly'
                    }

                    else if (globalWeekNumber == number) {
                        weekTriggered = true;
                        clearCollections();
                        self.settings.selected.dates = days.map(day => day.dataset.calendarDay)
                        self.update({ dates: true })
                        setArrayOfDates(self.selectedDates);
                        isYear = false;
                        getReport(cleanReport);
                        loadChart();
                        setClickWeekNumber(number);
                        document.getElementById('reportType').innerText = 'Weekly'
                    }
                    else {
                        weekTriggered = true;
                        clearCollections();
                        self.settings.selected.dates = days.map(day => day.dataset.calendarDay)
                        self.update({ dates: true })
                        setArrayOfDates(self.selectedDates);
                        isYear = false;
                        getReport(cleanReport);
                        loadChart();
                        setClickWeekNumber(number);
                        document.getElementById('reportType').innerText = 'Weekly'
                    }
                }
            },
        }

        const calendar = new VanillaCalendar("#calendar", options)
        calendar.init()
    });

    var cleanReport;
    var globalSelectedDates = [];
    var globalSelectedYear = new Date().getFullYear();
    var globalSelectedMonth = new Date().getMonth();
    let globalWeekNumber;
    var isYear = false;
    let weekTriggered = false;
    //TODO Make a Collection --- sa papel ani ang flow--- OBJECT - ARRAY - OBJECT - ARRAY
    var collections = [{
        cableName: 'SEAUS',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'SJC',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'C2C',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'EAC',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'TGN',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    }]; // Collections that will show in the graph
    //Initialized para dili labad mag debug


    function getReport(cables) {
        var a = 0;
        var box_of_cables = []
        incidentTypeChecker(cables);

        //THE CODE BELOW IS THE BIGGEST FLAW! COMMENTED IT AND SLEPT 3 HOURS TO REDO THE LOGIC OF ALL TO MAKE THEM INDEPENDENT TO EACH OTHER THAN BEING DEPENDENT TO COLLECTION
        //console.log(cables);
        // if (globalSelectedDates.length > 1) {
        //     for (let i = 0; i < cables.length; i++) {
        //         if (new Date(cables[i].startDate).setHours(0, 0, 0, 0) >= new Date(globalSelectedDates[0]).setHours(0, 0, 0, 0) && new Date(cables[i].startDate).setHours(0, 0, 0, 0) <= new Date(globalSelectedDates[globalSelectedDates.length - 1]).setHours(0, 0, 0, 0)) {
        //             box_of_cables.push(cables[i]);
        //         }
        //     }
        //     incidentTypeChecker(box_of_cables)
        //     console.log(collections);
        // }

        // else if (isYear == true) {
        //     for (let i = 0; i < cables.length; i++) {
        //         if (new Date(cables[i].startDate).getFullYear() == globalSelectedYear && new Date(cables[i].startDate).getFullYear() != isNaN()) {
        //             box_of_cables.push(cables[i]);
        //         }
        //     }
        //     incidentTypeChecker(box_of_cables);
        //     console.log(collections);
        // }

        // else {
        //     cables.forEach(element => {
        //         if (new Date(element.startDate).getMonth() == globalSelectedMonth && new Date(element.startDate).getFullYear() == globalSelectedYear) { // added one cuz 1st month starts at 0
        //             box_of_cables.push(element)
        //         }
        //     });
        //     incidentTypeChecker(box_of_cables);
        //     console.log(collections);
        // }
        getCableYearlyReportToGraph();
        return collections;
    }

    function startUpLoadData(cables) {
        var dirtyReportHandler = cables;
        const cleanReportHandler = (cables) => {
            const uniqueTicketNames = new Set();
            const filteredCombinedCableNames = [];
            cables.combinedCableNames.forEach((cable) => {
                if (!uniqueTicketNames.has(cable.ticketName)) {
                    uniqueTicketNames.add(cable.ticketName);
                    filteredCombinedCableNames.push(cable);
                }
            });

            return filteredCombinedCableNames;
        };

        cleanReport = cleanReportHandler(dirtyReportHandler);
        getReport(cleanReport);
        loadChart();
        hideSpinner();
        document.getElementById('reportType').innerText = 'Monthly'
        // Actual data loading and rendering logic here

    }

    function setMonthOrYear(month, year) {
        globalSelectedMonth = month;
        globalSelectedYear = year;
    }

    function setYear(year) {
        globalSelectedYear = year
    }

    function setArrayOfDates(selectedDates) {
        globalSelectedDates = [] // ensure the global dates is empty
        globalSelectedDates = selectedDates;
    }


    // Checker para dili sakit sa mata once mag debug
    function incidentTypeChecker(cable) {
        for (var i = 0; i < cable.length; i++) {
            if (cable[i].incidentType.toString() == "Outage") locationChecker(cable[i], 0);
            else if (cable[i].incidentType.toString() == 'Partial Outage') locationChecker(cable[i], 0)
            else locationChecker(cable[i], 1);
        }

    }
    // pwede rani sila ma isa pero hahaha

    function locationChecker(cable, index) {
        var cable_name = cable.combinedName.split(" ");
        let collectionIndex = 0;

        for (const item of collections) {
            if (item.cableName === cable_name[0]) {
                if (cable.location.toLowerCase().includes('dry')) {
                    collections[collectionIndex].incidentType[index][0].dry.push(cable)
                }
                else if (cable.location.toLowerCase().includes('wet')) {
                    collections[collectionIndex].incidentType[index][0].wet.push(cable)
                }
                else if (cable.location.toLowerCase().includes('undetermined')) {
                    collections[collectionIndex].incidentType[index][0].under.push(cable)
                }
                else if (cable.location.toLowerCase().includes('backhaul')) {
                    collections[collectionIndex].incidentType[index][0].back.push(cable)
                }
                collectionIndex = 0;
                break;
            }
            else {
                collectionIndex++;
                continue;
            }
        }
    }
    function clearCollections() {
        collections.forEach((collection) => {
            collection.incidentType.forEach((incidentArray) => {
                incidentArray.forEach((incidentType) => {
                    incidentType.dry = [];
                    incidentType.wet = [];
                    incidentType.under = [];
                    incidentType.back = [];
                });
            });
        });
        globalSelectedDates = [];
    }

    function collectAllTicketsForEachCable() {
        const allTickets = {};
        collections.forEach((collection) => {
            const cableName = collection.cableName;
            const tickets = [];
            collection.incidentType.forEach((incidentArray, arrayIndex) => {
                incidentArray.forEach((incidentType) => {
                    for (let key in incidentType) {
                        if (incidentType[key].length != 0) {
                            for (let i = 0; i < incidentType[key].length; i++) {
                                if (isYear == true && new Date(incidentType[key][i].startDate).getFullYear() == globalSelectedYear) {
                                    tickets.push(incidentType[key][i])
                                }

                                else if (globalSelectedDates.length > 1) {
                                    if (new Date(incidentType[key][i].startDate).setHours(0, 0, 0, 0) >= new Date(globalSelectedDates[0]).setHours(0, 0, 0, 0) && new Date(incidentType[key][i].startDate).setHours(0, 0, 0, 0) <= new Date(globalSelectedDates[globalSelectedDates.length - 1]).setHours(0, 0, 0, 0)) {
                                        tickets.push(incidentType[key][i])
                                    }
                                }
                                else if (new Date(incidentType[key][i].startDate).getMonth() == globalSelectedMonth && new Date(incidentType[key][i].startDate).getFullYear() == globalSelectedYear) {
                                    tickets.push(incidentType[key][i])
                                }
                            }
                        }
                    }
                });
            });
            // Assign the collected tickets to the corresponding cableName
            allTickets[cableName] = tickets;
        });

        return allTickets;
    }

    function generateTotalReportedSegments() {
        const totalSegments = {};
        collections.forEach((collection) => {
            const cableName = collection.cableName;
            // Initialize the count object for each cable system
            totalSegments[cableName] = {
                dry: 0,
                wet: 0,
                under: 0,
                back: 0
            };
            collection.incidentType.forEach((incidentArray, arrayIndex) => {
                incidentArray.forEach((incidentType) => {
                    for (let key in incidentType) {
                        if (incidentType[key].length != 0) {
                            for (let i = 0; i < incidentType[key].length; i++) {
                                if (isYear == true && new Date(incidentType[key][i].startDate).getFullYear() == globalSelectedYear) {
                                    totalSegments[cableName][key] += 1;
                                }

                                else if (globalSelectedDates.length > 1) {
                                    if (new Date(incidentType[key][i].startDate).setHours(0, 0, 0, 0) >= new Date(globalSelectedDates[0]).setHours(0, 0, 0, 0) && new Date(incidentType[key][i].startDate).setHours(0, 0, 0, 0) <= new Date(globalSelectedDates[globalSelectedDates.length - 1]).setHours(0, 0, 0, 0)) {
                                        totalSegments[cableName][key] += 1;
                                    }
                                }
                                else if (new Date(incidentType[key][i].startDate).getMonth() == globalSelectedMonth && new Date(incidentType[key][i].startDate).getFullYear() == globalSelectedYear) {
                                    totalSegments[cableName][key] += 1;
                                }
                            }
                        }
                    }
                });
            });
        })
        return totalSegments;
    }

    function incidentType() {
        const totalIncident = {};
        collections.forEach((collection) => {
            const cableName = collection.cableName;

            // Initialize the count object for each cable system
            totalIncident[cableName] = {
                Outage: 0,
                Planned: 0
            }
            for (let i = 0; i < collection.incidentType.length; i++) {
                for (let key in collection.incidentType[i][0]) {
                    if (collection.incidentType[i][0][key].length != 0) {
                        for (let element = 0; element < collection.incidentType[i][0][key].length; element++) {
                            if (i == 0) {
                                if (isYear == true && new Date(collection.incidentType[i][0][key][element].startDate).getFullYear()) {
                                    totalIncident[cableName].Outage += 1;
                                }
                                else if (globalSelectedDates.length > 1) {
                                    if (new Date(collection.incidentType[i][0][key][element].startDate).setHours(0, 0, 0, 0) >= new Date(globalSelectedDates[0]).setHours(0, 0, 0, 0) && new Date(collection.incidentType[i][0][key][element].startDate).setHours(0, 0, 0, 0) <= new Date(globalSelectedDates[globalSelectedDates.length - 1]).setHours(0, 0, 0, 0)) {
                                        totalIncident[cableName].Outage += 1;
                                    }
                                }
                                else if (new Date(collection.incidentType[i][0][key][element].startDate).getMonth() == globalSelectedMonth && new Date(collection.incidentType[i][0][key][element].startDate).getFullYear() == globalSelectedYear) {
                                    totalIncident[cableName].Outage += 1;
                                }
                            }
                            else {
                                if (isYear == true && new Date(collection.incidentType[i][0][key][element].startDate).getFullYear() == globalSelectedYear) {
                                    totalIncident[cableName].Planned += 1;
                                }
                                else if (globalSelectedDates.length > 1) {
                                    if (new Date(collection.incidentType[i][0][key][element].startDate).setHours(0, 0, 0, 0) >= new Date(globalSelectedDates[0]).setHours(0, 0, 0, 0) && new Date(collection.incidentType[i][0][key][element].startDate).setHours(0, 0, 0, 0) <= new Date(globalSelectedDates[globalSelectedDates.length - 1]).setHours(0, 0, 0, 0)) {
                                        totalIncident[cableName].Planned += 1;
                                    }
                                }
                                else if (new Date(collection.incidentType[i][0][key][element].startDate).getMonth() == globalSelectedMonth && new Date(collection.incidentType[i][0][key][element].startDate).getFullYear() == globalSelectedYear) {
                                    totalIncident[cableName].Planned += 1;
                                }
                            }
                        }
                    }
                    else continue;
                }
            }
        })

        return totalIncident;
    }
    function generateTotalRootCause(location_cause) {
        let totalRootCause = {};

        // Initialize root cause object for each cable system
        totalRootCause = {
            dry: {
                bmh_issue: 0,
                cable_fault: 0,
                card_failure: 0,
                configuration_issue: 0,
                fan_issue: 0,
                force_majeure: 0,
                government_private_project: 0,
                human_error: 0,
                pfe_issue: 0,
                physical_connection: 0,
                planned_maintenance: 0,
                shunt_fault: 0,
                subsea_equipment_fault: 0,
                unknown: 0
            },
            wet: {
                bmh_issue: 0,
                cable_fault: 0,
                card_failure: 0,
                configuration_issue: 0,
                fan_issue: 0,
                force_majeure: 0,
                government_private_project: 0,
                human_error: 0,
                pfe_issue: 0,
                physical_connection: 0,
                planned_maintenance: 0,
                shunt_fault: 0,
                subsea_equipment_fault: 0,
                unknown: 0
            },
            under: {
                bmh_issue: 0,
                cable_fault: 0,
                card_failure: 0,
                configuration_issue: 0,
                fan_issue: 0,
                force_majeure: 0,
                government_private_project: 0,
                human_error: 0,
                pfe_issue: 0,
                physical_connection: 0,
                planned_maintenance: 0,
                shunt_fault: 0,
                subsea_equipment_fault: 0,
                unknown: 0
            },
            back: {
                bmh_issue: 0,
                cable_fault: 0,
                card_failure: 0,
                configuration_issue: 0,
                fan_issue: 0,
                force_majeure: 0,
                government_private_project: 0,
                human_error: 0,
                pfe_issue: 0,
                physical_connection: 0,
                planned_maintenance: 0,
                shunt_fault: 0,
                subsea_equipment_fault: 0,
                unknown: 0
            }
        };
        collections.forEach((collection) => {   // better search solutions.. got no time refactoring since late na nakita ang flaw sa previous code
            for (let i = 0; i < collection.incidentType.length; i++) {
                for (let key in collection.incidentType[i][0]) {
                    if (collection.incidentType[i][0][key].length != 0) {
                        for (let element = 0; element < collection.incidentType[i][0][key].length; element++) {
                            let rootCause = collection.incidentType[i][0][key][element].rootCauseHigh.toLowerCase().replace(/ /g, '_');
                            rootCause = rootCause.replace('/', '_');
                            if (isYear == true && new Date(collection.incidentType[i][0][key][element].startDate).getFullYear() == globalSelectedYear) {
                                if (rootCause !== undefined) {
                                    totalRootCause[key][rootCause] += 1;
                                }
                            }
                            else if (globalSelectedDates.length > 1) {
                                if (new Date(collection.incidentType[i][0][key][element].startDate).setHours(0, 0, 0, 0) >= new Date(globalSelectedDates[0]).setHours(0, 0, 0, 0) && new Date(collection.incidentType[i][0][key][element].startDate).setHours(0, 0, 0, 0) <= new Date(globalSelectedDates[globalSelectedDates.length - 1]).setHours(0, 0, 0, 0)) {
                                    if (rootCause !== undefined) {
                                        totalRootCause[key][rootCause] += 1;
                                    }
                                }
                            }
                            else if (new Date(collection.incidentType[i][0][key][element].startDate).getMonth() == globalSelectedMonth && new Date(collection.incidentType[i][0][key][element].startDate).getFullYear() == globalSelectedYear) {
                                if (rootCause !== undefined) {
                                    totalRootCause[key][rootCause] += 1;
                                }
                            }
                        }
                    }
                    else continue;
                }
            }
        });

        return Object.values(totalRootCause[location_cause]);
    }

    function getCableYearlyReportToGraph() {
        let yearlyReport = {
            SEAUS: Array(12).fill(0),
            SJC: Array(12).fill(0),
            C2C: Array(12).fill(0),
            EAC: Array(12).fill(0),
            TGN: Array(12).fill(0)
        }

        collections.forEach((collection) => {
            collection.incidentType.forEach((incidentType) => {
                incidentType.forEach((element) => {
                    for (let key in element) {
                        if (element[key].length != 0) {
                            for (let i = 0; i < element[key].length; i++) {
                                let dateHolder = new Date(element[key][i].startDate)
                                if (dateHolder.getFullYear() == globalSelectedYear) {
                                    yearlyReport[collection.cableName][dateHolder.getMonth()] += 1;
                                }
                            }
                        }
                    }
                })
            })
        })
        return yearlyReport;
    }
    function setClickWeekNumber(week) {
        globalWeekNumber = week
    }
</script>
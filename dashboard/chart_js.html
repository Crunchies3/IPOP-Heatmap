<!-- for charts -->
<script>
    window.onload = (event) => {
        //load every data to a array
        showSpinner();
        google.script.run.withSuccessHandler(startUpLoadData).getAllCableNames();

    }

    // Function to show the spinner
    function showSpinner() {
        document.getElementById('spinnerModal').style.display = 'block';
    }

    // Function to hide the spinner
    function hideSpinner() {
        document.getElementById('spinnerModal').style.display = 'none';
    }

    // Example of showing spinner while loading data
    function ticketsCreatedDisplay() {
        document.getElementById('sea-us').innerText = collectAllTicketsForEachCable()['SEAUS'].length;
        document.getElementById('sjc').innerText = collectAllTicketsForEachCable()['SJC'].length;
        document.getElementById('c2c').innerText = collectAllTicketsForEachCable()['C2C'].length;
        document.getElementById('eac').innerText = collectAllTicketsForEachCable()['EAC'].length;
        document.getElementById('tgn').innerText = collectAllTicketsForEachCable()['TGN'].length;
        document.getElementById('totalticketDOM').innerText = collectAllTicketsForEachCable()['SEAUS'].length + collectAllTicketsForEachCable()['SJC'].length +
            collectAllTicketsForEachCable()['C2C'].length + collectAllTicketsForEachCable()['EAC'].length + collectAllTicketsForEachCable()['TGN'].length
    }

    function loadChart() {
        ticketsCreatedDisplay();
        // Pie chart incident type
        var pieChart = echarts.init(document.getElementById('pie-chart'));
        pieChart.setOption({
            color: ['#ff5858', '#A6C5F7', '#D2DDEC'],
            tooltip: { trigger: 'item' },
            legend: { bottom: '8%', left: 'center' },
            series: [{
                type: 'pie',
                radius: ['40%', '55%'],
                avoidLabelOverlap: false,
                label: { show: false, position: 'center' },
                labelLine: { show: false },
                data: [
                    { value: incidentType()['SEAUS'].Outage + incidentType()['C2C'].Outage + incidentType()['TGN'].Outage + incidentType()['SJC'].Outage + incidentType()['EAC'].Outage, name: 'Outage' },
                    { value: incidentType()['SEAUS'].Planned + incidentType()['C2C'].Planned + incidentType()['TGN'].Planned + incidentType()['SJC'].Planned + incidentType()['EAC'].Planned, name: 'Planned Activity' }
                ]
            }]
        });

        // Bar chart segment fault
        var segmentBarChart = echarts.init(document.getElementById('segment-bar-chart'));
        segmentBarChart.setOption({
            color: ['#155ebf', '#2C7BE5', '#A6C5F7', '#D2DDEC'],
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'shadow' }
            },
            legend: {},
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: { data: ['SEA-US', 'SJC', 'C2C', 'EAC', 'TGN-IA/P'] },
            yAxis: {},
            series: [
                { name: 'Dry Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [generateTotalReportedSegments()['SEAUS'].dry, generateTotalReportedSegments()['SJC'].dry, generateTotalReportedSegments()['C2C'].dry, generateTotalReportedSegments()['EAC'].dry, generateTotalReportedSegments()['TGN'].dry] },
                { name: 'Wet Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [generateTotalReportedSegments()['SEAUS'].wet, generateTotalReportedSegments()['SJC'].wet, generateTotalReportedSegments()['C2C'].wet, generateTotalReportedSegments()['EAC'].wet, generateTotalReportedSegments()['TGN'].wet] },
                { name: 'Undetermined', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [generateTotalReportedSegments()['SEAUS'].under, generateTotalReportedSegments()['SJC'].under, generateTotalReportedSegments()['C2C'].under, generateTotalReportedSegments()['EAC'].under, generateTotalReportedSegments()['TGN'].under] },
                { name: 'Backhaul', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [generateTotalReportedSegments()['SEAUS'].back, generateTotalReportedSegments()['SJC'].back, generateTotalReportedSegments()['C2C'].back, generateTotalReportedSegments()['EAC'].back, generateTotalReportedSegments()['TGN'].back] }
            ]
        });

        // Incident bar chart
        var incidentBarChart = echarts.init(document.getElementById('incident-bar-chart'));
        incidentBarChart.setOption({
            color: ['#ff5858', '#A6C5F7'],
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'shadow' }
            },
            legend: {},
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: { data: ['SEA-US', 'SJC', 'C2C', 'EAC', 'TGN-IA/P'] },
            yAxis: {},
            series: [
                { name: 'Outage', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [incidentType()['SEAUS'].Outage, incidentType()['C2C'].Outage, incidentType()['TGN'].Outage, incidentType()['SJC'].Outage, incidentType()['EAC'].Outage] },
                { name: 'Planned Activity', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: [incidentType()['SEAUS'].Planned, incidentType()['C2C'].Planned, incidentType()['TGN'].Planned, incidentType()['SJC'].Planned, incidentType()['EAC'].Planned] }
            ]
        });

        // Yearly tickets line chart
        var yearlyLineChart = echarts.init(document.getElementById('yearly-line-graph'));
        yearlyLineChart.setOption({
            tooltip: { trigger: 'axis' },
            legend: { data: ['SEA-US', 'SJC', 'C2C', 'EAC', 'TGN-IA/P'] },
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            toolbox: { feature: { saveAsImage: {} } },
            xAxis: {
                type: 'category',
                boundaryGap: false,
                data: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
            },
            yAxis: { type: 'value' },
            series: [
                { name: 'SEA-US', type: 'line', data: [78, 162, 94, 140, 55, 187, 123, 82, 149, 71], emphasis: { focus: 'series' } },
                { name: 'SJC', type: 'line', data: [134, 76, 189, 63, 95, 144, 182, 112, 153, 67, 125, 192], emphasis: { focus: 'series' } },
                { name: 'C2C', type: 'line', data: [158, 72, 142, 99, 186, 54, 135, 178, 81, 147, 162, 105], emphasis: { focus: 'series' } },
                { name: 'EAC', type: 'line', data: [90, 177, 68, 121, 159, 50, 130, 84, 196, 73, 141, 111], emphasis: { focus: 'series' } },
                { name: 'TGN-IA/P', type: 'line', data: [118, 67, 159, 84, 142, 93, 177, 53, 135, 101, 168, 190], emphasis: { focus: 'series' } }
            ]
        });

        // Root cause bar chart
        var rootCauseBarChart = echarts.init(document.getElementById('root-cause-bar'));
        rootCauseBarChart.setOption({
            color: ['#155ebf', '#2C7BE5', '#A6C5F7', '#D2DDEC'],
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'shadow' }
            },
            legend: {},
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: {
                data: ['BMH Issue', 'Cable Fault', 'Card Failure', 'Configuration Issue',
                    'Fan Issue', 'Force Majeure', 'Government/Private Project', 'Human Error',
                    'PFE Issue', 'Physical Connection', 'Planned Maintenance', 'Shunt Fault',
                    'Subsea Equipment Fault', 'Unknown']
            },
            yAxis: {},
            series: [
                { name: 'Dry Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: generateTotalRootCause('dry') },
                { name: 'Wet Segment', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: generateTotalRootCause('wet') },
                { name: 'Undetermined', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: generateTotalRootCause('under') },
                { name: 'Backhaul', type: 'bar', stack: 'total', label: { show: true }, emphasis: { focus: 'series' }, data: generateTotalRootCause('back') }
            ]
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
        const options = {
            settings: {
                range: {
                    disableGaps: true,
                },
                selection: {
                    day: "multiple-ranged"
                },
                visibility: {
                    weekNumbers: true,
                    theme: 'light'
                }
            },
            actions: {
                clickYear(event, self) {
                    self.settings.selected.dates = [];
                    self.update({ dates: true });
                    clearCollections();
                    isYear = true;
                    setYear(self.selectedYear);
                    //setMonthOrYear(self.selectedMonth, self.selectedYear);
                    getReport(cleanReport);
                    loadChart();
                    aggregateTicketsByYear();
                    document.getElementById('reportType').innerText = 'Yearly'
                },
                clickMonth(event, self) {
                    self.settings.selected.dates = [];
                    self.update({ dates: true });
                    clearCollections();
                    setMonthOrYear(self.selectedMonth, self.selectedYear);
                    isYear = false;
                    getReport(cleanReport);
                    loadChart();
                    document.getElementById('reportType').innerText = 'Monthly'
                },
                clickArrow(event, self) {
                    self.settings.selected.dates = [];
                    self.update({ dates: true });
                    clearCollections();
                    setMonthOrYear(self.selectedMonth, self.selectedYear);
                    isYear = false;
                    getReport(cleanReport);
                    loadChart();
                    document.getElementById('reportType').innerText = 'Monthly'
                },
                /*
                Don't get confused if it says Day. this part is configured to be only in weeks
                vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
                */
                clickDay(event, self) {
                    if (self.selectedDates.length == 1) {
                        clearCollections();
                        setMonthOrYear(self.selectedMonth, self.selectedYear);
                        isYear = false;
                        getReport(cleanReport);
                        loadChart();
                        document.getElementById('reportType').innerText = 'Monthly'
                    }
                    else if (self.selectedDates[0] === undefined && self.selectedDates[1] === undefined) {
                        clearCollections();
                        setMonthOrYear(self.selectedMonth, self.selectedYear);
                        isYear = false;
                        getReport(cleanReport);
                        loadChart();
                        document.getElementById('reportType').innerText = 'Monthly'
                    }
                    else {
                        clearCollections();
                        setArrayOfDates(self.selectedDates);
                        isYear = false;
                        getReport(cleanReport);
                        loadChart();
                        document.getElementById('reportType').innerText = 'Custom Range'
                    }
                },
                //for clicking the week number
                clickWeekNumber(event, number, days, year, self) {
                    clearCollections();
                    self.settings.selected.dates = days.map(day => day.dataset.calendarDay)
                    self.update({ dates: true })
                    setArrayOfDates(self.selectedDates);
                    isYear = false;
                    getReport(cleanReport);
                    loadChart();
                    document.getElementById('reportType').innerText = 'Weekly'
                }
            },
        }

        const calendar = new VanillaCalendar("#calendar", options)
        calendar.init()
    });

    var cleanReport;
    var globalSelectedDates = [];
    var globalSelectedYear = new Date().getFullYear();
    var globalSelectedMonth = new Date().getMonth();
    var isYear = true;
    //TODO Make a Collection --- sa papel ani ang flow--- OBJECT - ARRAY - OBJECT - ARRAY
    var collections = [{
        cableName: 'SEAUS',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'SJC',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'C2C',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'EAC',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    },
    {
        cableName: 'TGN',
        incidentType: [[{ dry: [], wet: [], under: [], back: [] }],
        [{ dry: [], wet: [], under: [], back: [] }]]
    }]; // Collections that will show in the graph
    //Initialized para dili labad mag debug


    function getReport(cables) {
        var a = 0;
        var box_of_cables = []
        if (globalSelectedDates.length > 1) {
            for (let i = 0; i < cables.length; i++) {
                if (new Date(cables[i].startDate).setHours(0, 0, 0, 0) >= new Date(globalSelectedDates[0]).setHours(0, 0, 0, 0) && new Date(cables[i].startDate).setHours(0, 0, 0, 0) <= new Date(globalSelectedDates[globalSelectedDates.length - 1]).setHours(0, 0, 0, 0)) {
                    box_of_cables.push(cables[i]);
                }
            }
            incidentTypeChecker(box_of_cables)
            console.log(collections);
        }

        else if (isYear == true) {
            for (let i = 0; i < cables.length; i++) {
                if (new Date(cables[i].startDate).getFullYear() == globalSelectedYear && new Date(cables[i].startDate).getFullYear() != isNaN()) {
                    box_of_cables.push(cables[i]);
                }
            }
            incidentTypeChecker(box_of_cables);
            console.log(collections);
        }

        else {
            cables.forEach(element => {
                if (new Date(element.startDate).getMonth() == globalSelectedMonth && new Date(element.startDate).getFullYear() == globalSelectedYear) { // added one cuz 1st month starts at 0
                    box_of_cables.push(element)
                }
            });
            incidentTypeChecker(box_of_cables);
            console.log(collections);
        }
        return collections;
    }

    function startUpLoadData(cables) {
        var dirtyReportHandler = cables;
        const cleanReportHandler = (cables) => {
            const uniqueTicketNames = new Set();
            const filteredCombinedCableNames = [];
            cables.combinedCableNames.forEach((cable) => {
                if (!uniqueTicketNames.has(cable.ticketName)) {
                    uniqueTicketNames.add(cable.ticketName);
                    filteredCombinedCableNames.push(cable);
                }
            });

            return filteredCombinedCableNames;
        };

        cleanReport = cleanReportHandler(dirtyReportHandler);
        getReport(cleanReport);
        loadChart();
        hideSpinner();
        document.getElementById('reportType').innerText = 'Monthly'
        // Actual data loading and rendering logic here

    }

    function setMonthOrYear(month, year) {
        globalSelectedMonth = month;
        globalSelectedYear = year;
    }

    function setYear(year) {
        globalSelectedYear = year
    }

    function setArrayOfDates(selectedDates) {
        globalSelectedDates = [] // ensure the global dates is empty
        globalSelectedDates = selectedDates;
    }


    // Checker para dili sakit sa mata once mag debug
    // FIX LATER
    function incidentTypeChecker(cable) {
        for (var i = 0; i < cable.length; i++) {
            if (cable[i].incidentType.toString() == "Outage") locationChecker(cable[i], 0);
            else if (cable[i].incidentType.toString() == 'Partial Outage') locationChecker(cable[i], 0)
            else locationChecker(cable[i], 1);
        }

    }
    // pwede rani sila ma isa pero hahaha

    function locationChecker(cable, index) {
        var cable_name = cable.combinedName.split(" ");
        let collectionIndex = 0;

        for (const item of collections) {
            if (item.cableName === cable_name[0]) {
                if (cable.location.toLowerCase().includes('dry')) {
                    collections[collectionIndex].incidentType[index][0].dry.push(cable)
                }
                else if (cable.location.toLowerCase().includes('wet')) {
                    collections[collectionIndex].incidentType[index][0].wet.push(cable)
                }
                else if (cable.location.toLowerCase().includes('undetermined')) {
                    collections[collectionIndex].incidentType[index][0].under.push(cable)
                }
                else if (cable.location.toLowerCase().includes('backhaul')) {
                    collections[collectionIndex].incidentType[index][0].back.push(cable)
                }
                collectionIndex = 0;
                break;
            }
            else {
                collectionIndex++;
                continue;
            }
        }
    }
    function clearCollections() {
        collections.forEach((collection) => {
            collection.incidentType.forEach((incidentArray) => {
                incidentArray.forEach((incidentType) => {
                    incidentType.dry = [];
                    incidentType.wet = [];
                    incidentType.under = [];
                    incidentType.back = [];
                });
            });
        });
        globalSelectedDates = [];
    }

    function collectAllTicketsForEachCable() {
        const allTickets = {};

        collections.forEach((collection) => {
            const cableName = collection.cableName;
            const tickets = [];

            // Loop through incident types (Outage, Other) and collect tickets
            collection.incidentType.forEach((incidentArray) => {
                incidentArray.forEach((incidentType) => {
                    // Collect tickets from each category (dry, wet, under, back)
                    tickets.push(...incidentType.dry);
                    tickets.push(...incidentType.wet);
                    tickets.push(...incidentType.under);
                    tickets.push(...incidentType.back);
                });
            });

            // Assign the collected tickets to the corresponding cableName
            allTickets[cableName] = tickets;
        });
        return allTickets;
    }

    function generateTotalReportedSegments() { // hard
        const totalSegments = {};

        collections.forEach((collection) => {
            const cableName = collection.cableName;

            // Initialize the count object for each cable system
            totalSegments[cableName] = {
                dry: 0,
                wet: 0,
                under: 0,
                back: 0
            };

            // Loop through incident types (Outage, Other) and aggregate counts
            collection.incidentType.forEach((incidentArray, inex) => {
                incidentArray.forEach((incidentType) => {
                    totalSegments[cableName].dry += incidentType.dry.length;
                    totalSegments[cableName].wet += incidentType.wet.length;
                    totalSegments[cableName].under += incidentType.under.length;
                    totalSegments[cableName].back += incidentType.back.length;
                });
            });
        });
        return totalSegments;
    }

    function incidentType() {
        const totalIncident = {};
        collections.forEach((collection) => {
            const cableName = collection.cableName;

            // Initialize the count object for each cable system
            totalIncident[cableName] = {
                Outage: 0,
                Planned: 0
            };

            // Loop through incident types and count Outage and Planned incident
            collection.incidentType.forEach((incidentArray, index) => {
                incidentArray.forEach((incidentType) => {
                    if (index === 0) {
                        // Index 0 corresponds to 'Outage'
                        totalIncident[cableName].Outage += incidentType.dry.length;
                        totalIncident[cableName].Outage += incidentType.wet.length;
                        totalIncident[cableName].Outage += incidentType.under.length;
                        totalIncident[cableName].Outage += incidentType.back.length;

                    } else if (index === 1) {
                        // Index 1 corresponds to 'Planned'
                        totalIncident[cableName].Planned += incidentType.dry.length;
                        totalIncident[cableName].Planned += incidentType.wet.length;
                        totalIncident[cableName].Planned += incidentType.under.length;
                        totalIncident[cableName].Planned += incidentType.back.length;
                    }
                });
            });
        });
        console.log(totalIncident);
        return totalIncident;
    }
    function generateTotalRootCause(location_cause) {
        let totalRootCause = {};



        // Initialize root cause object for each cable system
        totalRootCause = {
            dry: {
                bmh_issue: 0,
                cable_fault: 0,
                card_failure: 0,
                configuration_issue: 0,
                fan_issue: 0,
                force_majeure: 0,
                government_private_project: 0,

                human_error: 0,
                pfe_issue: 0,
                physical_connection: 0,
                planned_maintenance: 0,
                shunt_fault: 0,
                subsea_equipment_fault: 0,
                unknown: 0
            },
            wet: {
                bmh_issue: 0,
                cable_fault: 0,
                card_failure: 0,
                configuration_issue: 0,
                fan_issue: 0,
                force_majeure: 0,
                government_private_project: 0,

                human_error: 0,
                pfe_issue: 0,
                physical_connection: 0,
                planned_maintenance: 0,
                shunt_fault: 0,
                subsea_equipment_fault: 0,
                unknown: 0
            },
            under: {
                bmh_issue: 0,
                cable_fault: 0,
                card_failure: 0,
                configuration_issue: 0,
                fan_issue: 0,
                force_majeure: 0,
                government_private_project: 0,

                human_error: 0,
                pfe_issue: 0,
                physical_connection: 0,
                planned_maintenance: 0,
                shunt_fault: 0,
                subsea_equipment_fault: 0,
                unknown: 0
            },
            back: {
                bmh_issue: 0,
                cable_fault: 0,
                card_failure: 0,
                configuration_issue: 0,
                fan_issue: 0,
                force_majeure: 0,
                government_private_project: 0,
                human_error: 0,
                pfe_issue: 0,
                physical_connection: 0,
                planned_maintenance: 0,
                shunt_fault: 0,
                subsea_equipment_fault: 0,
                unknown: 0
            }
        };
        collections.forEach((collection) => {
            // Loop through incident types and aggregate root causes
            collection.incidentType.forEach((incidentArray) => {
                incidentArray.forEach((incidentType) => {
                    ['dry', 'wet', 'under', 'back'].forEach((segment) => {
                        incidentType[segment].forEach((incident) => {
                            let rootCause = incident.rootCauseHigh.toLowerCase().replace(/ /g, '_');
                            rootCause = rootCause.replace('/', '_');

                            if (totalRootCause[segment][rootCause] !== undefined) {
                                totalRootCause[segment][rootCause] += 1;
                            } else {
                                totalRootCause[segment].unknown += 1;
                            }
                        });
                    });
                });
            });
        });

        return Object.values(totalRootCause[location_cause]);
    }

</script>